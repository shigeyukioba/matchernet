
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>matchernet_py_001.ekf &#8212; matchernet_py_001  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matchernet_py_001.ekf</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">matchernet_py_001</span> <span class="k">import</span> <span class="n">fn</span>
<span class="kn">from</span> <span class="nn">.matchernet</span> <span class="k">import</span> <span class="n">Bundle</span><span class="p">,</span> <span class="n">Matcher</span>
<span class="kn">from</span> <span class="nn">matchernet_py_001</span> <span class="k">import</span> <span class="n">state</span>
<span class="kn">from</span> <span class="nn">matchernet_py_001</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">print1</span><span class="p">,</span> <span class="n">print2</span><span class="p">,</span> <span class="n">print3</span><span class="p">,</span> <span class="n">print4</span><span class="p">,</span> <span class="n">print5</span>

<span class="c1">#=======================================================================</span>
<span class="c1">#  BundleEKFContinuousTime</span>
<span class="c1">#=======================================================================</span>

<div class="viewcode-block" id="BundleEKFContinuousTime"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.BundleEKFContinuousTime">[docs]</a><span class="k">class</span> <span class="nc">BundleEKFContinuousTime</span><span class="p">(</span><span class="n">Bundle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class BundleEKFContinuousTime is a Bundle part of an extended Kalman filter (EKF) model implemented as the BundleNet.</span>

<span class="sd">    See matchernet.py for general concept of the BundleNet, especially the general relationship between the &quot;Bundle&quot; and the &quot;Matcher&quot;.</span>

<span class="sd">    This class &quot;BundleEKFContinuousTime&quot; manages an internal state  x  and its dynamics model  f.</span>
<span class="sd">    The dynamics is defined as a probabilistic differential equation,</span>
<span class="sd">       dx/dt = f(x) + Q dw,</span>
<span class="sd">    where  x  is an  n  dimensional state vector variable,</span>
<span class="sd">           f  determines the intrinsic non-linear dynamics</span>
<span class="sd">                 by a map from n-dim to n-dim,</span>
<span class="sd">           dw is a Wiener process.</span>
<span class="sd">    This dynamics is locally linearlized and temporarily descritized</span>
<span class="sd">    as followings,</span>
<span class="sd">       x(t+dt) = dot( x(t), F ) + w(t), w(t) ~ N(0, dt*Q )</span>
<span class="sd">    where  F = exp( dt*A )  is the linear coefficient matrix</span>
<span class="sd">    that is defined with the Jacobian matrix  A = df/dx.</span>

<span class="sd">    This class stores the internal state as a temporal estimation of</span>
<span class="sd">    the posterior probability density function</span>
<span class="sd">       q(x) = N( mu, Sigma )</span>
<span class="sd">    that is parameterized as</span>
<span class="sd">           mu = self.state[&quot;mu&quot;]  (1,n)-np.array</span>
<span class="sd">    and</span>
<span class="sd">           Sigma = self.state[&quot;Sigma&quot;]  (n,n)-np.array.</span>

<span class="sd">    Dynamics function  f  is stored as a function instance</span>
<span class="sd">        self.f</span>
<span class="sd">    of a class  Fn   which is defined in  fn.py .</span>


<span class="sd">    In EKF algorithm, the BundleEKFContinuousTime updates</span>
<span class="sd">       posterior  q(x)  through following steps.</span>

<span class="sd">       1. Updates posterior  q(x)  according to the intrinsic dynamics</span>
<span class="sd">       with an arbitrary time step  dt.</span>
<span class="sd">       It is implemented in the method  self.step_dynamics().</span>

<span class="sd">       2. Updates posterior  q(x)  in order to increase objective functions</span>
<span class="sd">       that are defined in Matchers.</span>
<span class="sd">       It is implemented in the method  self.accept_feedback().</span>


<span class="sd">    One Bundle can connect to multiple Matchers. Thus, the difference signals</span>
<span class="sd">    from all the connected Matchers are applied simultaneously.</span>

<span class="sd">    The dynamics function  f  is fixed at the initialized value.</span>
<span class="sd">    See an extented class</span>
<span class="sd">        BundleEKFContinuousTimeTrainable (to be implemented soon)</span>
<span class="sd">    for a similar class with trainable dynamics function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="c1"># Dimsnsionarity of the state variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">StateMuSigma</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_control_params</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">LinearFn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="c1">#self.bw = matchernet.bundleWeight(numSteps)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BundleEKFContinuousTime</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The main routine that is called from brica.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;=== In Bundle </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span> <span class="c1"># key is one of the matcher names</span>
            <span class="k">if</span> <span class="n">inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;==   accepting feedback from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">accept_feedback</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="n">print3</span><span class="p">(</span><span class="s2">&quot;1: mu=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_countup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">regularize_cov_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">])</span>
        <span class="n">print3</span><span class="p">(</span><span class="s2">&quot;1: mu=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]))</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_initialize_control_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_optimizer_ready</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">=</span> <span class="mf">0.0001</span> <span class="c1"># Leaning rate for dynamics  f</span>

    <span class="k">def</span> <span class="nf">_countup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;time_stamp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;time_stamp&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callcount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callcount</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_initialize_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>

<div class="viewcode-block" id="BundleEKFContinuousTime.accept_feedback"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.BundleEKFContinuousTime.accept_feedback">[docs]</a>    <span class="k">def</span> <span class="nf">accept_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fbst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overriding matchernet.Bundle.accept_feedback()</span>
<span class="sd">        This method updates the state of the current Bundle with accepting a feedback, fbst, from each Matcher linking from the current Bundle, according to the following update rule.</span>

<span class="sd">            mu &lt;-- mu + dmu,</span>
<span class="sd">            Sigma &lt;-- Sigma - dSigma,</span>

<span class="sd">        where  mu  and  Sigma  stands for the probabilistic state of the current bundle  q(x) = N( mu, Sigma ),</span>
<span class="sd">        and  dmu  and  dSigma  stands for the feedback state coming from the corresponding Matcher.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmu</span> <span class="o">=</span> <span class="n">fbst</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
        <span class="n">dSigma</span> <span class="o">=</span> <span class="n">fbst</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span>

        <span class="n">print4</span><span class="p">(</span><span class="s2">&quot;dmu=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dmu</span><span class="p">))</span>
        <span class="n">print4</span><span class="p">(</span><span class="s2">&quot;dSigma=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dSigma</span><span class="p">))</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="n">weight</span><span class="o">*</span><span class="n">dmu</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sigma</span> <span class="o">-</span> <span class="n">weight</span><span class="o">*</span><span class="n">dSigma</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>
        <span class="c1">#self.Q = (1-weight*self.lr) * Q + weight*self.lr * np.dot(dmu.T,dmu)</span>

<div class="viewcode-block" id="BundleEKFContinuousTime.step_dynamics"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.BundleEKFContinuousTime.step_dynamics">[docs]</a>    <span class="k">def</span> <span class="nf">step_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method updates  self.state  using the dynamics model,</span>

<span class="sd">            dx/dt  =  f(x) + Q dw.</span>

<span class="sd">        In order to (1) temporally discretization, (2) locally liniarization, and (3) consideration of probabilistic state, the actual update rule becomes the following manner</span>

<span class="sd">            mu &lt;-- mu + dot( x(t), F )</span>
<span class="sd">            Sigma &lt;-- F&#39; * Sigma * F + dt * Q</span>

<span class="sd">        where  F = exp( dt*A )  is a linear coefficient matrix calculated with the Jacobian matrix  A = (df/dx).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">x</span><span class="p">(</span> <span class="n">mu</span> <span class="p">)</span>
        <span class="c1"># Note:  mu.shape = (1,n), A.shape = (n,n)</span>
        <span class="n">matrix_F</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">calc_matrix_F</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">mu</span><span class="p">,</span> <span class="n">matrix_F</span> <span class="p">)</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">matrix_F</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>  <span class="n">Sigma</span><span class="p">),</span> <span class="n">matrix_F</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sigma</span></div></div>
        <span class="c1"># [&quot;time_stamp&quot;] is updated in the method self._countup()</span>

<span class="c1">#=======================================================================</span>
<span class="c1">#  Matcher_EKF</span>
<span class="c1">#=======================================================================</span>

<div class="viewcode-block" id="MatcherEKF"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.MatcherEKF">[docs]</a><span class="k">class</span> <span class="nc">MatcherEKF</span><span class="p">(</span><span class="n">Matcher</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class MatcherEKF is a Matcher part of an extended Kalman filter (EKF) model implemented as the BundleNet.</span>

<span class="sd">    See matchernet.py for general concept of the BundleNet, especially the general relationship between the &quot;Bundle&quot; and the &quot;Matcher&quot;.</span>

<span class="sd">    In short, the followings are what MatcherEKF does in the BundleNet.</span>
<span class="sd">     (1) Defines a link between two bundles  b0  and  b1</span>
<span class="sd">     (2) Receives current states of bundles  b0  and  b1, which are probability density function  q(x0) = N( mu0, Sigma0 )  and  q(x1) = N( mu1, Sigma1 )</span>
<span class="sd">     (3) Evaluates error  E  (or log likelihood  lnL  )  defined as a function of the current bundle states.</span>
<span class="sd">     (4) Calculates the derivatives of  E  w.r.t. the states,</span>
<span class="sd">         dmu0 = d E / d mu0, dSigma0 = d E / d Sigma0</span>
<span class="sd">         dmu1 = d E / d mu1, dSigma1 = d E / d Sigma1</span>
<span class="sd">     (5) Returns the derivatives as &quot;feedback state&quot; from the current Matcher to the corresponding Bundles.</span>

<span class="sd">    The MatcherEKF defines a error (or contradiction) between the two bundles as</span>

<span class="sd">       E =  z S^{-1} z&#39;</span>

<span class="sd">    and corresponding log-likelihood function as</span>

<span class="sd">       lnl = - (1/2) z S^{-1} z&#39; - (1/2) ln det 2 pi S</span>

<span class="sd">    where</span>

<span class="sd">       z = g0( mu0 ) - g1( mu1 )</span>

<span class="sd">    stands for the error (or contradiction) between the states of the two Bundles.  g0()  and  g1()  are arbitrary user-defined functions. The user can set  g0  and  g1  identity function  mu0 = g0(mu0)  and  mu1 = g1(mu1)  for the simplest case.</span>
<span class="sd">    State variables of the bundles are denoted as normal distributions</span>

<span class="sd">       q(x0)  ==  N( mu0,  Sigma0 )</span>
<span class="sd">       q(x1)  ==  N( mu1,  Sigma1 )</span>

<span class="sd">    Then, the total variance  S  of the current matcher is defined as</span>

<span class="sd">       S = C0 Sigma0 C0&#39; + C1 Sigma1 C1&#39;</span>

<span class="sd">    where  C0 = (dg0/dx)  and  C1 = (dg1/dx)  are Jacobian matrices. Note that C0 and C1 are identity matrices and  S = Sigma0 + Sigma1  holds in the simplest case.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">):</span> <span class="c1"># b0 and b1 are the Bundles to be linked to the current Matcher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatcherEKF</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b0name</span> <span class="o">=</span> <span class="n">b0</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b1name</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">n</span> <span class="c1"># dim. of B0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n1</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">n</span> <span class="c1"># dim. of B1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_call_of_state_record</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_model</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts0_recent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># the most recent value of the time_stamp of b0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts1_recent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># that of b1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_component</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n0</span>      <span class="c1"># dim. of g0(x0), g1(x1)</span>
        <span class="c1"># self.g0 is an identity function as a default observation model</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g0</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">LinearFn</span><span class="p">(</span><span class="n">dim_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n0</span><span class="p">,</span><span class="n">dim_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g0</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">C0</span>
        <span class="c1"># self.g1 is also an identity function</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g1</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">LinearFn</span><span class="p">(</span><span class="n">dim_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n1</span><span class="p">,</span><span class="n">dim_out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g1</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">C1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id1</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="MatcherEKF.print_state"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.MatcherEKF.print_state">[docs]</a>    <span class="k">def</span> <span class="nf">print_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;== Printing the matcher&#39;s state&quot;</span><span class="p">)</span>
        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;name=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;b0=</span><span class="si">{}</span><span class="s2">, b1=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b0name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">b1name</span><span class="p">))</span>
        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;n0=</span><span class="si">{}</span><span class="s2">, n1=</span><span class="si">{}</span><span class="s2">, n=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The main routine that is called from brica.</span>
<span class="sd">        The input variable  &#39;inputs&#39;  is a python dictionary object that brings all the current states of bundles.</span>
<span class="sd">        Ex.</span>

<span class="sd">          inputs = {&quot;Bundle0&quot;, st0, &quot;Bundle1&quot;, st1}</span>

<span class="sd">        The output variable &#39;results&#39; is a python dictionary object which brings all the feedback states to the corresponding bundles.</span>
<span class="sd">        Ex.</span>

<span class="sd">          results = {&quot;Bundle0&quot;, fbst0, &quot;Bundle1&quot;, fbst1}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>

<div class="viewcode-block" id="MatcherEKF.forward"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.MatcherEKF.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Main method that evaluates the error and derivatives.</span>
<span class="sd">           z = g0(mu0) - g1(mu1)</span>
<span class="sd">           C0 = (d g0/ d mu0)   &lt;-- Jacobian</span>
<span class="sd">           C1 = (d g1/ d mu1)   &lt;-- Jacobian</span>
<span class="sd">           S = C0 Sigma0 C0&#39; + C1 Sigma1 C1&#39;</span>
<span class="sd">           err2 = z S^{-1} z&#39;</span>
<span class="sd">           lnL = - (1/2) err2 - (1/2) log det( 2*pi*S )</span>
<span class="sd">           K0 = Sigma0 C0&#39; S^{-1}</span>
<span class="sd">           K1 = Sigma1 C1&#39; S^{-1}</span>
<span class="sd">           dmu0 &lt;-- K0 z,  dSigma0 &lt;-- K0 C0 dSigma0</span>
<span class="sd">           dmu1 &lt;-- K1 z,  dSigma1 &lt;-- K1 C1 dSigma1</span>

<span class="sd">        Note</span>
<span class="sd">           When bundle  b0  is a Observer that provides sequencial data, the user may consider the simplest setting with the identity function  g0()  and a fixed noise matrix  Sigma0. In this case, the observer omits the corresponding feedback signal  dmu0  and  dSigma0, and the total covariance  S  becomes that of a standard EKF,</span>
<span class="sd">               S = R + C1 Sigma1 C1</span>
<span class="sd">           where  R = Sigma0.</span>
<span class="sd">           In other words, user may provide a fixed noise matrix  Sigma0 = R  in the observer in order to set the observation noise model.</span>
<span class="sd">           Missing observation can be described as temporally setting of large diagonal elements of  Sigma0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print3</span><span class="p">(</span><span class="s2">&quot;Matcher_EKF forward&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnL_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#self.R = self.Sigma0 + self.Sigma1</span>
        <span class="n">print4</span><span class="p">(</span><span class="s2">&quot;mu0_shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">print4</span><span class="p">(</span><span class="s2">&quot;mu1_shape=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu1</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g0</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu1</span><span class="p">)</span>
        <span class="n">C0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g0</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="p">)</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu1</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma0</span><span class="p">),</span> <span class="n">C0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma1</span><span class="p">),</span> <span class="n">C1</span><span class="p">)</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">I</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;z=</span><span class="si">{z}</span><span class="s2">, S=</span><span class="si">{S}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">))</span>
        <span class="n">dum_sign</span><span class="p">,</span> <span class="n">slogdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span> <span class="n">S</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnL_t</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span> <span class="n">SI</span><span class="p">),</span> <span class="n">z</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">err2</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnL_t</span> <span class="o">-=</span> <span class="n">slogdet</span> <span class="o">/</span><span class="mf">2.0</span>
        <span class="n">K0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma0</span><span class="p">,</span> <span class="n">C0</span><span class="p">),</span> <span class="n">SI</span><span class="p">)</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma1</span><span class="p">,</span> <span class="n">C1</span><span class="p">),</span> <span class="n">SI</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dmu0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span> <span class="n">K0</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span>   <span class="c1">#### HERE it is fixed! ####</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dmu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">z</span><span class="p">,</span> <span class="n">K1</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dSigma0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">K0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">C0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma0</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dSigma1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">K1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">C1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma1</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnL</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnL_t</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">print3</span><span class="p">(</span><span class="s2">&quot;lnL_t = </span><span class="si">{lnLt}</span><span class="s2">, lnL = </span><span class="si">{lnL}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lnLt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lnL_t</span><span class="p">,</span><span class="n">lnL</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lnL</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatcherEKF.backward"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.MatcherEKF.backward">[docs]</a>    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the observation models</span>
<span class="sd">              self.g0 and self.g1</span>
<span class="sd">        if they are variables.</span>
<span class="sd">        (to be implemented soon)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> backward&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatcherEKF.update"><a class="viewcode-back" href="../../matchernet_py_001.html#matchernet_py_001.ekf.MatcherEKF.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;method self.update()</span>
<span class="sd">         is called from self.__call__()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b0state</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b0name</span><span class="p">]</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b0state</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b1state</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b1name</span><span class="p">]</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1state</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu0</span> <span class="o">=</span> <span class="n">d0</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma0</span> <span class="o">=</span> <span class="n">d0</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts0</span> <span class="o">=</span> <span class="n">d0</span><span class="p">[</span><span class="s2">&quot;time_stamp&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;time_stamp&quot;</span><span class="p">]</span>

        <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;=== In Matcher </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: mu0=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu0</span><span class="p">))</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: Sigma0=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma0</span><span class="p">))</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: mu1=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu1</span><span class="p">))</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: Sigma1=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma1</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts0</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts0_recent</span><span class="p">:</span>
            <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;  b0.state is not updated&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts1_recent</span><span class="p">:</span>
            <span class="n">print2</span><span class="p">(</span><span class="s2">&quot;  b1.state is not updated&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts0_recent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts1_recent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b0name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dmu0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b0name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dSigma0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b1name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dmu1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b1name</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dSigma1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: dmu0=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dmu0</span><span class="p">))</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: dSigma0=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dSigma0</span><span class="p">))</span>

        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: dmu1=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dmu1</span><span class="p">))</span>
        <span class="n">print5</span><span class="p">(</span><span class="s2">&quot;5: dSigma1=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dSigma1</span><span class="p">))</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">matchernet_py_001</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../matchernet_py_001.html">matchernet_py_001 package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Author.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>